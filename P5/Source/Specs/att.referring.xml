<?xml version="1.0" encoding="UTF-8"?><!--
Copyright TEI Consortium. 
Dual-licensed under CC-by and BSD2 licences 
See the file COPYING.txt for details
$Date$
$Id$
--><?xml-model href="http://jenkins.tei-c.org/job/TEIP5-dev/lastSuccessfulBuild/artifact/P5/release/xml/tei/odd/p5.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<classSpec xmlns="http://www.tei-c.org/ns/1.0" module="tei" type="atts" ident="att.referring">
	<desc versionDate="2017-03-21" xml:lang="en">provides attributes for specifying the beginning
		and end of a linguistic or textual segment, by addressing the character offsets or by
		identifying the edge elements via their ID.</desc>
	<classes/>

	<!-- the fragment *[local-name() = ('span')] is an expression of a kludge that makes it impossible
	     at present to say "only elements that add themselves to this class" 
	     
	Ideally, the sequence should be extensible automatically, but that is unfortunately currently the 
	task of the person preparing a customization -->

	<constraintSpec scheme="schematron" ident="default_is_URI"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:xsd="http://www.w3.org/2001/XMLSchema-datatypes">
		<constraint>
			<sch:rule context="*[local-name() = ('span')][not(@referringMode) and @from and @to]">
				<sch:assert test="@from castable as xsd:anyURI">The default form of @from is a URI</sch:assert>
				<sch:report test="@to and not(@to castable as xsd:anyURI)">The default form of @to is a URI</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>
	<constraintSpec scheme="schematron" ident="two-and-three-match-one"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[@referringMode eq 'pointer']">
				<sch:assert test="@from castable as xsd:anyURI">when @referringMode is 'pointer',
					@from must be a URI</sch:assert>
				<sch:assert test="@to castable as xsd:anyURI">when @referringMode is 'pointer', @to
					must be a URI</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode = ('character','icp','byte')]">
				<sch:assert test="@from castable as xsd:nonNegativeInteger">when @referringMode is
						'<sch:value-of select="@referringMode"/>', @from must be a counting
					number</sch:assert>
				<sch:assert test="@to castable as xsd:nonNegativeInteger">when @referringMode is
						'<sch:value-of select="@referringMode"/>', @to must be a counting
					number</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode eq 'temporal.w3c']">
				<sch:assert
					test="@from castable as xsd:date or @from castable as xsd:gYear or @from castable as xsd:gMonth or @from castable as xsd:gDay or @from castable as xsd:gYearMonth or @from castable as xsd:gMonthDay or @from castable as xsd:time or @from castable as xsd:dateTime"
					>when @referringMode is 'temporal.iso', @from must conform to the W3C/XSD time-date
					format</sch:assert>
				<sch:assert
					test="@to castable as xsd:date or @to castable as xsd:gYear or @to castable as xsd:gMonth or @to castable as xsd:gDay or @to castable as xsd:gYearMonth or @to castable as xsd:gMonthDay or @to castable as xsd:time or @to castable as xsd:dateTime"
					>when @referringMode is 'temporal.iso', @to must conform to the W3C/XSD time-date
					format</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode eq 'temporal.iso']">
				<sch:assert
					test="@from castable as xsd:date or @from castable as xsd:gYear or @from castable as xsd:gMonth or @from castable as xsd:gDay or @from castable as xsd:gYearMonth or @from castable as xsd:gMonthDay or @from castable as xsd:time or @from castable as xsd:dateTime or matches(@from, '[0-9.,DHMPRSTWYZ/:+\-]+')"
					>when @referringMode is 'temporal.iso', @from must conform to the ISO time-date
					format</sch:assert>
				<sch:assert
					test="@to castable as xsd:date or @to castable as xsd:gYear or @to castable as xsd:gMonth or @to castable as xsd:gDay or @to castable as xsd:gYearMonth or @to castable as xsd:gMonthDay or @to castable as xsd:time or @to castable as xsd:dateTime or matches(@to, '[0-9.,DHMPRSTWYZ/:+\-]+')"
					>when @referringMode is 'temporal.iso', @to must conform to the ISO time-date
					format</sch:assert>
			</sch:rule>
		</constraint>
	</constraintSpec>
	
	<constraintSpec ident="tofrom" scheme="isoschematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
<!--	this rule should be unnecessary, because the datatypes on @to and @from are independently restricted.
		but their restriction appears to be ineffective... (?) -->
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to or @from]">
				<sch:report  test="contains(normalize-space(@to),' ') or contains(normalize-space(@from),' ')"
					> The attributes @to and @from on <sch:name/> may each contain only a single
					value</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>
	<constraintSpec ident="tonotfrom" scheme="isoschematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to]">
				<sch:report test="@to and not(@from)"> If @to is supplied on <sch:name/>, @from must
					be supplied as well</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>

	<attList>
		<attDef ident="referringMode" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies whether the span/segment edges
				are identified as <val>numeric</val> offsets or as references to ID
				(<val>URI</val>).</desc>
			<datatype>
				<dataRef key="teidata.enumerated"/>
			</datatype>
			<defaultVal>pointer</defaultVal>
			<valList type="closed">
				<valItem ident="pointer"  >
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by pointing at
						elements (e.g. <gi>w</gi>, <gi>c</gi> or <gi>seg</gi>) that can be pointed
						at by means of an URI (which most often means that they have
							<att>xml:id</att> attributes defined).</desc>
				</valItem>
				<valItem ident="character">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers)</desc>
				</valItem>
				<valItem ident="icp">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers) identifying inter-character points. In e.g.
						the string "point", inter-character points are marked by vertical lines:
						|p|o|i|n|t| (by convention, there is an icp before the first character and
						after the last one).</desc>
				</valItem>
				<valItem ident="byte">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers) addressing bytes.</desc>
				</valItem>
				<valItem ident="temporal.iso">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by offsets
						expressed as values that conform to the international standard <title>Data
							elements and interchange formats – Information interchange –
							Representation of dates and times</title>.</desc>
				</valItem>
				<valItem ident="temporal.w3c">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by offsets
						expressed as values that conform to the W3C <title ref="#XSD2">XML Schema
							Part 2: Datatypes Second Edition</title> specification.</desc>
				</valItem>
			</valList>
		</attDef>
		<attDef ident="from" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the starting point of the range
				of character offsets or elements that can be pointed at with an URI.</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
		<attDef ident="to" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the end-point of the range of
				character offsets or elements that can be pointed at with an URI.</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
	</attList>
	<listRef>
		<ptr target="#STECAT"/>
	</listRef>
</classSpec>
