<?xml version="1.0" encoding="UTF-8"?><!--
Copyright TEI Consortium. 
Dual-licensed under CC-by and BSD2 licences 
See the file COPYING.txt for details
$Date$
$Id$
--><?xml-model href="http://jenkins.tei-c.org/job/TEIP5-dev/lastSuccessfulBuild/artifact/P5/release/xml/tei/odd/p5.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<classSpec xmlns="http://www.tei-c.org/ns/1.0" module="tei" type="atts" ident="att.referring">
	<desc versionDate="2017-03-21" xml:lang="en">provides attributes for specifying the beginning
		and end of a linguistic or textual segment, by addressing the character offsets or by
		identifying the edge elements via their ID.</desc>
	<classes/>

	<!-- the fragment *[local-name() = ('span')] is an expression of a kludge that makes it impossible
	     at present to say "only elements that add themselves to this class" 
	     
	Ideally, the sequence should be extensible automatically, but that is unfortunately currently the 
	task of the person preparing a customization -->

	<constraintSpec scheme="schematron" ident="default_mode"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[local-name() = ('span')][not(@referringMode) and @from and @to]">
				<sch:assert test="@from castable as xsd:anyURI">The default form of @from is a URI</sch:assert>
				<sch:assert test="@to castable as xsd:anyURI">The default form of @to is a URI</sch:assert>
			</sch:rule>
		</constraint>
	</constraintSpec>
	
	<constraintSpec scheme="schematron" ident="two-and-three-match-one"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[@referringMode eq 'pointer']">
				<sch:assert test="@from castable as xsd:anyURI">When @referringMode is 'pointer',
					@from must be a URI</sch:assert>
				<sch:assert test="@to castable as xsd:anyURI">When @referringMode is 'pointer', @to
					must be a URI</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode eq 'id']">
				<sch:assert test="id(substring(@from,2))">When @referringMode is 'id',
					@from must be pointing at an existing local target</sch:assert>
				<sch:assert test="id(substring(@to,2))">When @referringMode is 'id',
					@to must be pointing at an existing local target</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode = ('character','icp','byte')]">
				<sch:assert test="@from castable as xsd:int">When @referringMode is
						'<sch:value-of select="@referringMode"/>', @from must be a non-negative integer</sch:assert>
				<sch:assert test="@to castable as xsd:int">When @referringMode is
					'<sch:value-of select="@referringMode"/>', @to must be a non-negative integer</sch:assert>
			</sch:rule>
		</constraint>
	</constraintSpec>
	
	<constraintSpec ident="tofrom" scheme="schematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
<!--	originally defined in span.xml
		this rule should be unnecessary, because the datatypes on @to and @from are independently restricted
		(in attDef below), but that restriction appears to be ineffective... (?) -->
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to or @from]">
				<sch:report  test="contains(normalize-space(@to),' ') or contains(normalize-space(@from),' ')"
					>The attributes @to and @from on <sch:name/> may each contain only a single
					value</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>
	<constraintSpec ident="tonotfrom" scheme="schematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<!--originally defined in span.xml-->
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to]">
				<sch:report test="@to and not(@from)">If @to is supplied on <sch:name/>, @from must
					be supplied as well</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>

	<attList>
		<attDef ident="referringMode" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies whether the span/segment edges
				are identified as numeric offsets or as pointers (URIs or fragment identifiers). The
				default value of this attribute is <val>pointer</val> and it is optional in cases
				where edges are identified by pointing. Otherwise, it has to be present.</desc>
			<datatype>
				<dataRef key="teidata.enumerated"/>
			</datatype>
			<defaultVal>pointer</defaultVal>
			<valList type="closed">
				<valItem ident="pointer">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by pointing at
						elements (e.g. <gi>w</gi>, <gi>c</gi> or <gi>seg</gi>) that can be pointed
						at by means of an URI (which most often means that they have
							<att>xml:id</att> attributes defined).</desc>
				</valItem>
				<valItem ident="id">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by pointing at
						existing elements (e.g. <gi>w</gi>, <gi>c</gi> or <gi>seg</gi>) that carry
							<att>xml:id</att> attributes; this value ensures ID validation -- in
						this respect, it is analogous to the IDREF data types of DTDs.</desc>
				</valItem>
				<valItem ident="character">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers); note that a separate project-specific
						convention regulates the value of the starting index (0 or 1).</desc>
				</valItem>
				<valItem ident="icp">
					<desc versionDate="2017-03-21" xml:lang="en">"icp" stands for "inter-character
						point". Edges are identified by numeric offsets (non-negative integers)
						identifying inter-character points. In e.g. the string "point",
						inter-character points are marked by vertical lines: |p|o|i|n|t| (by
						convention, there is an icp before the first character and after the last
						one); note that a separate project-specific convention regulates the value
						of the starting index (0 or 1). ISO LAF advocates 0 as the start index.</desc>
				</valItem>
				<valItem ident="byte">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers) addressing bytes. Note that this low-level
						indexing type ignores XML or any other structuring.</desc>
				</valItem>
			</valList>
		</attDef>
		<attDef ident="from" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the starting point of a sequence of characters
				or bytes, or of elements that can be pointed at with a URI.</desc>
			<desc versionDate="2007-12-20" xml:lang="ko">현재 부호를 붙이는 단락의 처음을 명시함; <att>to</att> 속성과 같이 쓰이지 않으면
				전체 문단을 명시함.</desc>
			<desc versionDate="2007-05-02" xml:lang="zh-TW">指出被註解段落的起點；若沒有使用屬性<att>to</att>，則指出全部段落。</desc>
			<desc versionDate="2008-04-05" xml:lang="ja">当該注釈対象の始点を示す．属性<att>to</att>がない場合は，対象全 体を示す．</desc>
			<desc versionDate="2007-06-12" xml:lang="fr">précise le début du passage sur lequel porte
				l'annotation ; s'il n'est pas accompagné d'un attribut <att>to</att>, désigne alors
				l'intégralité du passage</desc>
			<desc versionDate="2007-05-04" xml:lang="es">especifica el principio del pasaje que se anota; si
				no aparece con el atributo <att>to</att>, especifica el pasaje entero.</desc>
			<desc versionDate="2007-01-21" xml:lang="it">indica l'inizio di un brano annotato; se non è
				accompagnato dall'attributo <att>to</att> indica l'inero brano</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
		<attDef ident="to" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the end-point of a sequence of characters
				or bytes, or of elements that can be pointed at with a URI.</desc>
			<desc versionDate="2007-12-20" xml:lang="ko">부호를 붙이는 단락의 끝을 명시한다.</desc>
			<desc versionDate="2007-05-02" xml:lang="zh-TW">指出被註解段落的終點。</desc>
			<desc versionDate="2008-04-05" xml:lang="ja">注釈対象の終点を示す．</desc>
			<desc versionDate="2007-06-12" xml:lang="fr">spécifie la fin du passage annoté.</desc>
			<desc versionDate="2007-05-04" xml:lang="es">especifica el final del pasaje que se anota.</desc>
			<desc versionDate="2007-01-21" xml:lang="it">indica la fine del brano annotato</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
	</attList>
	<exemplum xml:lang="en">
		<p>The example below comes from a part of the CoMParS (Collection of Multi-lingual Parallel
			Sequences) project and presents a fragment of a monolingual subcorpus of German.</p>
		<p>The individual sequences (in this case, a sentence) are listed in the <gi>text</gi> part
			of the corpus, while the linguistic analysis is performed in the <gi>standOff</gi> part,
			which consists, among others, of segmentation information. CoMParS adheres to ISO LAF
			principles and uses inter-character points with the indexing starting at 0.</p>

		<!--	@valid should become "true" once the modification is incorporated into the Guidelines	-->
		<egXML xmlns="http://www.tei-c.org/ns/Examples" valid="feasible">
			<text xml:lang="de">
				<body>
					<ab xml:id="deu-ab1" n="1">Ich habe mich im Winter in dir verliebt.</ab>
				</body>
			</text>
			<!--        
'I'c'h' 'h'a'b'e' 'm'i'c'h' 'i'm' 'W'i'n't'e'r' 'i'n' 'd'i'c'h' 'v'e'r'l'i'e'b't'.'
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  -->
			<standOff xmlns="">
				<listAnnotation n="1" corresp="#deu-ab1" type="sequence">
					<listAnnotation type="segmentation">
						<seg from="0" to="3" xml:id="deu-ab1tok1">Ich</seg>
						<seg from="4" to="8" xml:id="deu-ab1tok2">habe</seg>
						<seg from="9" to="13" xml:id="deu-ab1tok3">mich</seg>
						<seg from="14" to="16" xml:id="deu-ab1tok4">im</seg>
						<seg from="17" to="23" xml:id="deu-ab1tok5">Winter</seg>
						<seg from="24" to="26" xml:id="deu-ab1tok6">in</seg>
						<seg from="27" to="31" xml:id="deu-ab1tok7">dich</seg>
						<seg from="32" to="40" xml:id="deu-ab1tok8">verliebt</seg>
						<seg from="40" to="41" xml:id="deu-ab1tok9">.</seg>
					</listAnnotation>
				</listAnnotation>
			</standOff>
		</egXML>
		<p>The CoMParS ODD contains the following statements that (a) include <gi>seg</gi> into the
			att.referring class, and (b) change the default value of the <att>referringMode</att> to
				<val>icp</val>. The first part will hopefully be accepted by the Council together with this ticket or afterwards, while the second part is forced by the lack of a mechanism that would make attribute classes aware of the elements that belong to them. This mechanism is on the Council's to-do list.
			<egXML xmlns="http://www.tei-c.org/ns/Examples" valid="true">
				<elementSpec ident="seg" module="linking" mode="change">
					<classes mode="change">
						<memberOf key="att.referring"/>
					</classes>
				</elementSpec>
				<classSpec ident="att.referring" mode="change" type="atts" module="tei">
					<constraintSpec scheme="schematron" ident="default_mode" mode="replace">
						<constraint xmlns:sch="http://purl.oclc.org/dsdl/schematron">
							<sch:rule
								context="*[local-name() = ('span','seg')][not(@referringMode) and @from and @to]">
								<sch:assert test="@from castable as xsd:nonNegativeInteger">The
									default form of @from is a non-negative integer</sch:assert>
								<sch:assert test="@to castable as xsd:nonNegativeInteger">The
									default form of @to is a non-negative integer</sch:assert>
							</sch:rule>
						</constraint>
					</constraintSpec>
					<attList>
						<attDef ident="referringMode" usage="opt" mode="change">
							<defaultVal>icp</defaultVal>
						</attDef>
					</attList>
				</classSpec>
			</egXML>
		</p>
	</exemplum>
	<remarks versionDate="2017-03-21" xml:lang="en">
		<p>When <att>referringMode</att> assumes numeric values, two theoretical options are
			possible for the start index. Some systems assume that indexing starts with 0, some
			assume that the initial index value is 1. This decision is not reflected by
				<att>referringMode</att> but should be documented in the header, together with other
			project-specific encoding decisions. Linguistic analysis in the ISO LAF (Linguistic
			Annotation Framework, ISO 24612:2012) assumes inter-character points (represented here
			by the value <val>icp</val>) and indices starting at 0.</p>
	</remarks>
	<listRef>
		<ptr target="#STECAT"/>
	</listRef>
</classSpec>
