<?xml version="1.0" encoding="UTF-8"?><!--
Copyright TEI Consortium. 
Dual-licensed under CC-by and BSD2 licences 
See the file COPYING.txt for details
$Date$
$Id$
--><?xml-model href="http://jenkins.tei-c.org/job/TEIP5-dev/lastSuccessfulBuild/artifact/P5/release/xml/tei/odd/p5.nvdl" type="application/xml" schematypens="http://purl.oclc.org/dsdl/nvdl/ns/structure/1.0"?>
<classSpec xmlns="http://www.tei-c.org/ns/1.0" module="tei" type="atts" ident="att.referring">
	<desc versionDate="2017-03-21" xml:lang="en">provides attributes for specifying the beginning
		and end of a linguistic or textual segment, by addressing the character offsets or by
		identifying the edge elements via their ID.</desc>
	<classes/>

	<!-- the fragment *[local-name() = ('span')] is an expression of a kludge that makes it impossible
	     at present to say "only elements that add themselves to this class" 
	     
	Ideally, the sequence should be extensible automatically, but that is unfortunately currently the 
	task of the person preparing a customization -->

	<constraintSpec scheme="schematron" ident="default_is_URI"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[local-name() = ('span')][not(@referringMode) and @from and @to]">
				<sch:assert test="@from castable as xsd:anyURI">The default form of @from is a URI</sch:assert>
				<sch:report test="@to and not(@to castable as xsd:anyURI)">The default form of @to is a URI</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>
	<constraintSpec scheme="schematron" ident="two-and-three-match-one"
		xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[@referringMode eq 'pointer']">
				<sch:assert test="@from castable as xsd:anyURI">When @referringMode is 'pointer',
					@from must be a URI</sch:assert>
				<sch:assert test="@to castable as xsd:anyURI">When @referringMode is 'pointer', @to
					must be a URI</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode eq 'id']">
				<sch:assert test="id(substring(@from,2))">When @referringMode is 'id',
					@from must be pointing at an existing local target</sch:assert>
				<sch:assert test="id(substring(@to,2))">When @referringMode is 'id',
					@to must be pointing at an existing local target</sch:assert>
			</sch:rule>
			<sch:rule context="*[@referringMode = ('character','icp','byte')]">
				<sch:assert test="@from castable as xsd:nonNegativeInteger">When @referringMode is
						'<sch:value-of select="@referringMode"/>', @from must be a non-negative integer</sch:assert>
				<sch:assert test="@to castable as xsd:nonNegativeInteger">When @referringMode is
					'<sch:value-of select="@referringMode"/>', @to must be a non-negative integer</sch:assert>
			</sch:rule>
		</constraint>
	</constraintSpec>
	
	<constraintSpec ident="tofrom" scheme="isoschematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
<!--	this rule should be unnecessary, because the datatypes on @to and @from are independently restricted.
		but their restriction appears to be ineffective... (?) -->
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to or @from]">
				<sch:report  test="contains(normalize-space(@to),' ') or contains(normalize-space(@from),' ')"
					>The attributes @to and @from on <sch:name/> may each contain only a single
					value</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>
	<constraintSpec ident="tonotfrom" scheme="isoschematron" xmlns:sch="http://purl.oclc.org/dsdl/schematron">
		<constraint>
			<sch:rule context="*[local-name() = ('span')][@to]">
				<sch:report test="@to and not(@from)">If @to is supplied on <sch:name/>, @from must
					be supplied as well</sch:report>
			</sch:rule>
		</constraint>
	</constraintSpec>

	<attList>
		<attDef ident="referringMode" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies whether the span/segment edges
				are identified as numeric offsets or as pointers (URIs or fragment identifiers). The
				default value of this attribute is <val>pointer</val> and it is optional in cases
				where edges are identified by pointing. Otherwise, it has to be present.</desc>
			<datatype>
				<dataRef key="teidata.enumerated"/>
			</datatype>
			<defaultVal>pointer</defaultVal>
			<valList type="closed">
				<valItem ident="pointer">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by pointing at
						elements (e.g. <gi>w</gi>, <gi>c</gi> or <gi>seg</gi>) that can be pointed
						at by means of an URI (which most often means that they have
							<att>xml:id</att> attributes defined).</desc>
				</valItem>
				<valItem ident="id">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by pointing at
						existing elements (e.g. <gi>w</gi>, <gi>c</gi> or <gi>seg</gi>) that carry
							<att>xml:id</att> attributes; this value ensures ID validation -- in
						this respect, it is analogous to the IDREF data types of DTDs.</desc>
				</valItem>
				<valItem ident="character">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers); note that a separate project-specific
						convention regulates the value of the starting index (0 or 1).</desc>
				</valItem>
				<valItem ident="icp">
					<desc versionDate="2017-03-21" xml:lang="en">"icp" stands for "inter-character
						point". Edges are identified by numeric offsets (non-negative integers)
						identifying inter-character points. In e.g. the string "point",
						inter-character points are marked by vertical lines: |p|o|i|n|t| (by
						convention, there is an icp before the first character and after the last
						one); note that a separate project-specific convention regulates the value
						of the starting index (0 or 1). ISO LAF advocates 0 as the start index.</desc>
				</valItem>
				<valItem ident="byte">
					<desc versionDate="2017-03-21" xml:lang="en">edges are identified by numeric
						offsets (non-negative integers) addressing bytes. Note that this low-level
						indexing type ignores XML or any other structuring.</desc>
				</valItem>
			</valList>
			<exemplum xml:lang="en">
				<p>The example below comes from a part of the CoMParS (Collection of Multi-lingual
					Parallel Sequences) project that stores a monolingual subcorpus of German.</p>
				<p>The individual sequences (in this case, a sentence) are listed in the
						<gi>text</gi> part of the corpus, while linguistic analysis is performed in
					the <gi>standOff</gi> part, which consists, among others, of segmentation
					information. CoMParS adheres to ISO LAF principles and uses inter-character
					points with the indexing starting at 0.</p>
				<egXML xmlns="http://www.tei-c.org/ns/Examples" valid="false">
					<text xml:lang="de">
						<body>
							<ab xml:id="deu-ab1" n="1">
								<seg xml:id="deu-ab1seg1" xml:space="preserve">Ich habe mich im Winter in dir verliebt.</seg>
							</ab>
						</body>
					</text>
<!--
'I'c'h' 'h'a'b'e' 'm'i'c'h' 'i'm' 'W'i'n't'e'r' 'i'n' 'd'i'r' 'v'e'r'l'i'e'b't'.'
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0   -->
					<standOff>
						<listAnnotation n="1" corresp="#deu-ab1" type="sequence">
							<listAnnotation type="segmentation">
								<seg from="0" to="3" xml:id="deu-ab1tok1">Ich</seg>
								<seg from="4" to="8" xml:id="deu-ab1tok2">habe</seg>
								<seg from="9" to="13" xml:id="deu-ab1tok3">mich</seg>
								<seg from="14" to="16" xml:id="deu-ab1tok4">im</seg>
								<seg from="17" to="23" xml:id="deu-ab1tok5">Winter</seg>
								<seg from="24" to="26" xml:id="deu-ab1tok6">in</seg>
								<seg from="27" to="30" xml:id="deu-ab1tok7">dir</seg>
								<seg from="31" to="39" xml:id="deu-ab1tok8">verliebt</seg>
								<seg from="39" to="40" xml:id="deu-ab1tok9">.</seg>
							</listAnnotation>
						</listAnnotation>
					</standOff>
				</egXML>
			</exemplum>
		</attDef>
		<attDef ident="from" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the starting point of a sequence of characters
				or bytes, or of elements that can be pointed at with a URI.</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
		<attDef ident="to" usage="opt">
			<desc versionDate="2017-03-21" xml:lang="en">specifies the end-point of a sequence of characters
				or bytes, or of elements that can be pointed at with a URI.</desc>
			<datatype minOccurs="1" maxOccurs="1">
				<dataRef key="teidata.referring"/>
			</datatype>
		</attDef>
	</attList>
	<remarks versionDate="2017-03-21" xml:lang="en">
		<p>When <att>referringMode</att> assumes numeric values, two theoretical options are
			possible for the start index. Some systems assume that indexing starts with 0, some
			assume that the initial index value is 1. This decision is not reflected by
				<att>referringMode</att> but should be documented in the header, together with other
			project-specific encoding decisions. Linguistic analysis in the ISO LAF (Linguistic
			Annotation Framework) assumes inter-character points (represented here by the value
				<val>icp</val>) and indices starting at 0.</p>
	</remarks>
	<listRef>
		<ptr target="#STECAT"/>
	</listRef>
</classSpec>
